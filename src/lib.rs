// use crate::obao::creator::*;
// use crate::obao::slicer::*;
pub mod obao;

/*
 * Tests to see everything is working.
 */
#[cfg(test)]
mod correctness_tests {
    use super::*;
    use obao::creator::ObaoData;
    use obao::slicer::{BAO_CHUNK_SIZE, ObaoSlice, generate_random_chunk_index};
    use std::fs::File;
    use rand::Rng;
    use std::io::{Read, Cursor};

    #[test]
    fn verify_slicing() -> Result<(), Box<dyn std::error::Error>> {
        // See if our Slice is equivalent to that generated by native bao code

        // Create a random input.
        let mut whole_input = vec![0u8; 1 << 20];
        rand::thread_rng().fill(&mut whole_input[..]);

        // Create a random ObaoData.
        let obao_data = ObaoData::new(&whole_input)?;

        // Extract our Obao Data
        let obao = obao_data.obao;
        let file_size = obao_data.file_size;

        // Generate a random chunk index.
        let chunk_index = generate_random_chunk_index(file_size);

        // Use the outboard encoding to extract a slice from the file.
        // Requires the whole file
        let mut extractor = bao::encode::SliceExtractor::new_outboard(
            Cursor::new(&whole_input[..]),
            Cursor::new(&obao[..]),
            chunk_index as u64,
            BAO_CHUNK_SIZE.try_into().unwrap(),
        );
        let mut slice = Vec::new();
        extractor.read_to_end(&mut slice)?;

        // Now do the same thing, but this time supply only one chunk of the file.

        // Make the chunk.
        let chunk = &whole_input[chunk_index..chunk_index + BAO_CHUNK_SIZE];
        // Create a ObaoSlice.
        let obao_slice = ObaoSlice::new(obao, chunk, chunk_index)?;
        // Extract the slice.
        let slice2 = obao_slice.slice;

        // Check that we got exactly the same slice.
        assert_eq!(slice, slice2);
        Ok(())
    }

    #[test]
    fn verify_random_slice() -> Result<(), Box<dyn std::error::Error>> {
        // See if we can verify a slice from a piece of random data.

        // Create a random input.
        let mut whole_input = vec![0u8; 1 << 20];
        rand::thread_rng().fill(&mut whole_input[..]);

        // Create a random ObaoData.
        let obao_data = ObaoData::new(&whole_input)?;

        // Extract our Obao Data
        let obao = obao_data.obao;
        let hash = obao_data.hash;
        let file_size = obao_data.file_size;

        // Generate a random chunk index.
        let chunk_index = generate_random_chunk_index(file_size);
        let chunk = &whole_input[chunk_index..chunk_index + BAO_CHUNK_SIZE];

        // Create a new ObaoSlice from the chunk.
        let obao_slice = ObaoSlice::new(obao, chunk, chunk_index)?;

        // Verify the ObaoSlice against the file chunk. This should return true.
        assert_eq!(obao_slice.verify(&hash)?, true);
        Ok(())
    }

    #[test]
    fn decode_random_slice() -> Result<(), Box<dyn std::error::Error>> {
        // See if we can verify a slice from a piece of random data.

        // Create a random input.
        let mut whole_input = vec![0u8; 1 << 20];
        rand::thread_rng().fill(&mut whole_input[..]);

        // Create a random ObaoData.
        let obao_data = ObaoData::new(&whole_input)?;

        // Extract our Obao Data
        let obao = obao_data.obao;
        let hash = obao_data.hash;
        let file_size = obao_data.file_size;

        // Generate a random chunk index.
        let chunk_index = generate_random_chunk_index(file_size);
        let chunk = &whole_input[chunk_index..chunk_index + BAO_CHUNK_SIZE];

        // Create a new ObaoSlice from the chunk.
        let obao_slice = ObaoSlice::new(obao, chunk, chunk_index)?;

        // Decode the ObaoSlice. This should return our original chunk.
        assert_eq!(obao_slice.decode(&hash)?, chunk);
        Ok(())
    }

    #[test]
    fn bad_slice() -> Result<(), Box<dyn std::error::Error>> {
        // See if we can force a failure by supplying a bad chunk to create our slice.

        // Create a random input.
        let mut whole_input = vec![0u8; 1 << 20];
        rand::thread_rng().fill(&mut whole_input[..]);

        // Create a random ObaoData.
        let obao_data = ObaoData::new(&whole_input)?;

        // Extract our Obao Data
        let obao = obao_data.obao;
        let hash = obao_data.hash;
        let file_size = obao_data.file_size;

        // Generate new random input.
        let mut whole_bad_input = vec![0u8; 1 << 20];
        rand::thread_rng().fill(&mut whole_bad_input[..]);

        // Create a random chunk index.
        let chunk_index = generate_random_chunk_index(file_size);
        let bad_chunk = &mut whole_bad_input[chunk_index..chunk_index + BAO_CHUNK_SIZE];

        // Create a new ObaoSlice from the chunk.
        let obao_slice = ObaoSlice::new(obao, bad_chunk, chunk_index)?;

        // Verify the ObaoSlice against the file chunk. This should return false.
        assert_eq!(obao_slice.verify(&hash)?, false);
        Ok(())
    }

    #[test]
    fn bad_hash() -> Result<(), Box<dyn std::error::Error>> {
        // See if we can force a failure by supplying a bad hash to verify our slice.

        // Create a random input.
        let mut whole_input = vec![0u8; 1 << 20];
        rand::thread_rng().fill(&mut whole_input[..]);

        // Create a random ObaoData.
        let obao_data = ObaoData::new(&whole_input)?;

        // Extract our Obao Data
        let obao = obao_data.obao;
        let file_size = obao_data.file_size;

        // Generate a random chunk index.
        let chunk_index = generate_random_chunk_index(file_size);
        let chunk = &mut whole_input[chunk_index..chunk_index + BAO_CHUNK_SIZE];

        // Change the last byte of the chunk.
        chunk[chunk.len() - 1] ^= 1;

        // Create a new ObaoSlice from the chunk.
        let obao_slice = ObaoSlice::new(obao, chunk, chunk_index)?;

        // Change a single byte of our input and generate a new hash.
        whole_input[chunk_index + BAO_CHUNK_SIZE - 1] ^= 1;
        let bad_hash = blake3::hash(&whole_input[..]);

        // Verify the ObaoSlice against the file chunk. This should return false.
        assert_eq!(obao_slice.verify(&bad_hash)?, false);
        Ok(())
    }

    #[test]
    fn decode_and_verify_local_file() -> Result<(), Box<dyn std::error::Error>> {
        // See if we can verify a slice from a local file.

        // Read the file in as input
        let mut f = File::open("tests/files/ethereum.pdf")?;
        let mut whole_input = Vec::new();
        f.read_to_end(&mut whole_input)?;

        let obao_data = ObaoData::new(&whole_input)?;

        // Extract our Obao Data
        let obao = obao_data.obao;
        let hash = obao_data.hash;
        let file_size = obao_data.file_size;

        // Generate a random chunk index.
        let chunk_index = generate_random_chunk_index(file_size);
        let chunk = &whole_input[chunk_index..chunk_index + BAO_CHUNK_SIZE];

        // Create a new ObaoSlice from the chunk.
        let obao_slice = ObaoSlice::new(obao, chunk, chunk_index)?;

        // Verify the ObaoSlice against the file chunk. This should return true.
        assert_eq!(obao_slice.verify(&hash)?, true);
        // Decode the ObaoSlice. This should return our original chunk.
        assert_eq!(obao_slice.decode(&hash)?, chunk);
        Ok(())
    }
}

/*
    Performs the Obao encoding and logs overhead results
    See the README for more information.
 */
#[cfg(test)]
mod performance_tests {
    /* uses */
    use super::*;
    use serde::Serialize;
    use obao::creator::ObaoData;
    use obao::slicer::{ObaoSlice, BAO_CHUNK_SIZE};

    // The data associated with a single slice of a file.
    #[derive(Serialize)]
    struct SliceData {
        pub slice_index: usize, // The index of the slice.
        pub slice_name: String, // The name of the slice.
        pub size: usize,        // How big the slice is.
        pub verified: bool,     // Whether the slice has been verified.
    }

    // The data associated with tests run on a single file.
    #[derive(Serialize)]
    struct TestData {
        pub hash: String,
        // The hash of the file.
        pub size: usize,
        // The length of the file.
        pub blocks: usize,
        // How big the obao file is.
        pub obao_size: usize,
        // The number of Bao blocks in the file.
        pub slices: Vec<SliceData>, // The slices of the file.
    }

    // Iterate through all the files in the test directory and generate an ObaoData for each.
    // Save obao data in tests/obaos/<filename>.obao.
    // Then iterate through every chunk of the file and generate a slice of the ObaoData.
    // Save every slice in tests/slices/<filename>/<slice_index>
    // Compile results into a json file in tests/results/<filename>.json that describes TestData.
    #[test]
    fn run_tests() {
        // Make the tests/obaos directory if it doesn't exist.
        let obaos_dir = "tests/obaos";
        if !std::path::Path::new(obaos_dir).exists() {
            std::fs::create_dir(obaos_dir).unwrap();
        }
        // Make the tests/slices directory if it doesn't exist.
        let slices_dir = "tests/slices";
        if !std::path::Path::new(slices_dir).exists() {
            std::fs::create_dir(slices_dir).unwrap();
        }
        // Make the tests/results directory if it doesn't exist.
        let results_dir = "tests/results";
        if !std::path::Path::new(results_dir).exists() {
            std::fs::create_dir(results_dir).unwrap();
        }
        // Iterate through every file
        for entry in std::fs::read_dir("tests/files").unwrap() {
            // Declare a new TestData struct for this file.
            let mut file_data = TestData {
                hash: String::new(),
                size: 0,
                blocks: 0,
                obao_size: 0,
                slices: Vec::new(),
            };

            let entry = entry.unwrap();
            let path = entry.path();

            // The name of the file we're testing.
            let file_name = path.file_name().unwrap().to_str().unwrap();
            // The bytes of the file we're testing.
            let file_bytes = std::fs::read(&path).unwrap();

            // Create a new ObaoData for the file.
            let file_obao_data = ObaoData::new(&file_bytes).unwrap();
            // Save the ObaoData to a file.
            std::fs::write(
                format!("tests/obaos/{}.obao", file_name),
                &file_obao_data.obao,
            )
            .unwrap();

            // Extract info from the ObaoData.
            file_data.hash = file_obao_data.hash.to_string();
            file_data.size = file_obao_data.file_size;
            file_data.blocks = file_data.size / BAO_CHUNK_SIZE;
            file_data.obao_size = file_obao_data.obao.len();

            // Make a directory for the slices of this file.
            // Check if the directory exists. If it doesn't, create it.
            let slice_dir = format!("tests/slices/{}", file_name);
            if !std::path::Path::new(&slice_dir).exists() {
                std::fs::create_dir(&slice_dir).unwrap();
            }

            for i in 0..file_data.blocks {
                // The name of the slice.
                let slice_name = format!("{}/{}", file_name, i);
                // The bytes of the chunk from the file.
                let chunk = &file_bytes
                    [i * BAO_CHUNK_SIZE..(i + 1) * BAO_CHUNK_SIZE];

                // The actual obao slice for the chunk.
                let obao_slice = ObaoSlice::new(
                    file_obao_data.obao.clone(),
                    chunk,
                    i * BAO_CHUNK_SIZE,
                )
                .unwrap();

                // Verify the slice.
                let verified = obao_slice.verify(&file_obao_data.hash).unwrap();
                // The length of the slice.
                let size = obao_slice.slice.len();

                // Save the obao slice to a file.
                std::fs::write(
                    format!("tests/slices/{}/{}", file_name, i),
                    obao_slice.slice,
                )
                .unwrap();

                let slice_data = SliceData {
                    slice_index: i,
                    slice_name: slice_name.clone(),
                    size,
                    verified,
                };

                // Assert that the slice is verified.
                assert!(verified, "Slice {} is not verified.", &slice_name);
                // Assert that the slice is less than 2kb.
                assert!(
                    size < 2048,
                    "Slice {} is too large: {} b",
                    &slice_name,
                    size
                );

                file_data.slices.push(slice_data);
            }
            // Save file_data to a json file.
            let json = serde_json::to_string_pretty(&file_data).unwrap();
            std::fs::write(format!("tests/results/{}.json", file_name), json).unwrap();
        }
    }
}
