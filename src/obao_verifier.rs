use anyhow::{anyhow, Result, Error};
use std::convert::TryInto;
use std::io::prelude::*;
use std::io::{Cursor, SeekFrom};

// How big File chunks are with Bao
// TODO: Subject to change, we need to coordinate with bao team.
pub const BAO_CHUNK_SIZE: usize = 1024;

struct FakeSeeker<R: Read> {
    reader: R,
    bytes_read: u64,
}

impl<R: Read> FakeSeeker<R> {
    fn new(reader: R) -> Self {
        Self {
            reader,
            bytes_read: 0,
        }
    }
}

impl<R: Read> Read for FakeSeeker<R> {
    fn read(&mut self, buf: &mut [u8]) -> std::io::Result<usize> {
        let n = self.reader.read(buf)?;
        self.bytes_read += n as u64;
        Ok(n)
    }
}

impl<R: Read> Seek for FakeSeeker<R> {
    fn seek(&mut self, _: SeekFrom) -> std::io::Result<u64> {
        // Do nothing and return the current position.
        Ok(self.bytes_read)
    }
}

pub struct ObaoSlice {
    pub slice: Vec<u8>,
    pub start_index: usize
}

// Our Implementation for creating and verifying ObaoSlices from file chunks.
impl ObaoSlice {
    /// Generate a new ObaoSlice from a file.
    /// # Arguments
    /// * 'obao' - The bytes of the obao file to use to generate the ObaoSlice.
    /// * 'file_chunk' - The file chunk to use to generate the ObaoSlice. These chunk must be of size BAO_CHUNK_SIZE.
    ///                  Note that these chunks aligned with the obao file, and don't pass Chunk boundaries!
    /// * 'start_byte' - The byte offset of the first chunk from the file.
    /// Returns: A new ObaoSlice.
    pub fn new(obao: Vec<u8>, chunk: &[u8], start_index: usize) -> Result<ObaoSlice, Error> {
        // Check that the chunk is of the correct size.
        if chunk.len() != BAO_CHUNK_SIZE {
            return Err(anyhow!("Chunk is not of size {}", BAO_CHUNK_SIZE));
        }

        // Declare a Vector to hold our slice.
        let mut slice = Vec::new();
        // Extract the slice from the obao file.
        let mut slice_extractor = bao::encode::SliceExtractor::new_outboard(
            FakeSeeker::new(chunk),
            Cursor::new(&obao[..]),
            start_index as u64,
            BAO_CHUNK_SIZE.try_into().unwrap(),
        );
        // Extract the slice.
        slice_extractor.read_to_end(&mut slice)?;
        // Return the ObaoSlice.
        Ok(ObaoSlice { slice, start_index })
    }

    /// Verify the ObaoSlice against the file chunk.
    /// # Arguments
    /// * `hash` - The Blake3 hash of the file chunk.
    /// Returns: A bool indicating if the ObaoSlice is valid.
    pub fn verify(&self, hash: &bao::Hash) -> Result<bool> {
        // Declare a Vector to hold our decoding of the ObaoSlice.
        let mut decoded = Vec::new();

        // Decode the ObaoSlice.
        let mut decoder = bao::decode::SliceDecoder::new(
            &*self.slice,
            hash,
            self.start_index as u64,
            BAO_CHUNK_SIZE.try_into().unwrap(),
        );

        // Read the decoded ObaoSlice into the decoded Vector.
        match decoder.read_to_end(&mut decoded) {
            Err(_) => Ok(false),
            _ => Ok(true),
        }
    }

    /// Decode the ObaoSlice into a file chunk.
    /// # Arguments
    /// * `hash` - The Blake3 hash of the file chunk.
    /// Returns: A file chunk.
    pub fn decode(&self, hash: &bao::Hash) -> Result<Vec<u8>, Error> {
        // Declare a Vector to hold our decoding of the ObaoSlice.
        let mut decoded = Vec::new();

        // Decode the ObaoSlice.
        let mut decoder = bao::decode::SliceDecoder::new(
            &*self.slice,
            hash,
            self.start_index as u64,
            BAO_CHUNK_SIZE.try_into().unwrap(),
        );

        // Read the decoded ObaoSlice into the decoded Vector.
        match decoder.read_to_end(&mut decoded) {
            Err(_) => Err(anyhow!("ObaoSlice is invalid")),
            _ => Ok(decoded)
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::obao_creator::ObaoData;
    use rand::Rng;
    use std::fs::File;

    // Generate a random chunk index for a file of size `file_size`.
    pub fn generate_random_chunk_index(file_size: usize) -> usize {
        let range = file_size / BAO_CHUNK_SIZE;
        let start_index = rand::thread_rng().gen_range(0..range) * BAO_CHUNK_SIZE;

        // Return the index of the chunk.s
        start_index as usize
    }

    #[test]
    fn verify_slicing() -> Result<(), Box<dyn std::error::Error>> {
        // See if our Slice is equivalent to that generated by native bao code

        // Create a random input.
        let mut whole_input = vec![0u8; 1 << 20];
        rand::thread_rng().fill(&mut whole_input[..]);

        // Create a random ObaoData.
        let obao_data = ObaoData::new(&whole_input)?;

        // Extract our Obao Data
        let obao = obao_data.obao;
        let file_size = obao_data.file_size;

        // Generate a random chunk index.
        let chunk_index = generate_random_chunk_index(file_size);

        // Use the outboard encoding to extract a slice from the file.
        // Requires the whole file
        let mut extractor = bao::encode::SliceExtractor::new_outboard(
            Cursor::new(&whole_input[..]),
            Cursor::new(&obao[..]),
            chunk_index as u64,
            BAO_CHUNK_SIZE.try_into().unwrap(),
        );
        let mut slice = Vec::new();
        extractor.read_to_end(&mut slice)?;

        // Now do the same thing, but this time supply only one chunk of the file.

        // Make the chunk.
        let chunk = &whole_input[chunk_index..chunk_index + BAO_CHUNK_SIZE];
        // Create a ObaoSlice.
        let obao_slice = ObaoSlice::new(obao, chunk, chunk_index)?;
        // Extract the slice.
        let slice2 = obao_slice.slice;

        // Check that we got exactly the same slice.
        assert_eq!(slice, slice2);
        Ok(())
    }

    #[test]
    fn verify_random_slice() -> Result<(), Box<dyn std::error::Error>> {
        // See if we can verify a slice from a piece of random data.

        // Create a random input.
        let mut whole_input = vec![0u8; 1 << 20];
        rand::thread_rng().fill(&mut whole_input[..]);

        // Create a random ObaoData.
        let obao_data = ObaoData::new(&whole_input)?;

        // Extract our Obao Data
        let obao = obao_data.obao;
        let hash = obao_data.hash;
        let file_size = obao_data.file_size;

        // Generate a random chunk index.
        let chunk_index = generate_random_chunk_index(file_size);
        let chunk = &whole_input[chunk_index..chunk_index + BAO_CHUNK_SIZE];

        // Create a new ObaoSlice from the chunk.
        let obao_slice = ObaoSlice::new(obao, chunk, chunk_index)?;

        // Verify the ObaoSlice against the file chunk. This should return true.
        assert_eq!(obao_slice.verify(&hash)?, true);
        Ok(())
    }

    #[test]
    fn decode_random_slice() -> Result<(), Box<dyn std::error::Error>> {
        // See if we can verify a slice from a piece of random data.

        // Create a random input.
        let mut whole_input = vec![0u8; 1 << 20];
        rand::thread_rng().fill(&mut whole_input[..]);

        // Create a random ObaoData.
        let obao_data = ObaoData::new(&whole_input)?;

        // Extract our Obao Data
        let obao = obao_data.obao;
        let hash = obao_data.hash;
        let file_size = obao_data.file_size;

        // Generate a random chunk index.
        let chunk_index = generate_random_chunk_index(file_size);
        let chunk = &whole_input[chunk_index..chunk_index + BAO_CHUNK_SIZE];

        // Create a new ObaoSlice from the chunk.
        let obao_slice = ObaoSlice::new(obao, chunk, chunk_index)?;

        // Decode the ObaoSlice. This should return our original chunk.
        assert_eq!(obao_slice.decode(&hash)?, chunk);
        Ok(())
    }

    #[test]
    fn bad_slice() -> Result<(), Box<dyn std::error::Error>> {
        // See if we can force a failure by supplying a bad chunk to create our slice.

        // Create a random input.
        let mut whole_input = vec![0u8; 1 << 20];
        rand::thread_rng().fill(&mut whole_input[..]);

        // Create a random ObaoData.
        let obao_data = ObaoData::new(&whole_input)?;

        // Extract our Obao Data
        let obao = obao_data.obao;
        let hash = obao_data.hash;
        let file_size = obao_data.file_size;

        // Generate new random input.
        let mut whole_bad_input = vec![0u8; 1 << 20];
        rand::thread_rng().fill(&mut whole_bad_input[..]);

        // Create a random chunk index.
        let chunk_index = generate_random_chunk_index(file_size);
        let bad_chunk = &mut whole_bad_input[chunk_index..chunk_index + BAO_CHUNK_SIZE];

        // Create a new ObaoSlice from the chunk.
        let obao_slice = ObaoSlice::new(obao, bad_chunk, chunk_index)?;

        // Verify the ObaoSlice against the file chunk. This should return false.
        assert_eq!(obao_slice.verify(&hash)?, false);
        Ok(())
    }

    #[test]
    fn bad_hash() -> Result<(), Box<dyn std::error::Error>> {
        // See if we can force a failure by supplying a bad hash to verify our slice.

        // Create a random input.
        let mut whole_input = vec![0u8; 1 << 20];
        rand::thread_rng().fill(&mut whole_input[..]);

        // Create a random ObaoData.
        let obao_data = ObaoData::new(&whole_input)?;

        // Extract our Obao Data
        let obao = obao_data.obao;
        let file_size = obao_data.file_size;

        // Generate a random chunk index.
        let chunk_index = generate_random_chunk_index(file_size);
        let chunk = &mut whole_input[chunk_index..chunk_index + BAO_CHUNK_SIZE];

        // Change the last byte of the chunk.
        chunk[chunk.len() - 1] ^= 1;

        // Create a new ObaoSlice from the chunk.
        let obao_slice = ObaoSlice::new(obao, chunk, chunk_index)?;

        // Change a single byte of our input and generate a new hash.
        whole_input[chunk_index + BAO_CHUNK_SIZE - 1] ^= 1;
        let bad_hash = blake3::hash(&whole_input[..]);

        // Verify the ObaoSlice against the file chunk. This should return false.
        assert_eq!(obao_slice.verify(&bad_hash)?, false);
        Ok(())
    }

    #[test]
    fn decode_and_verify_local_file() -> Result<(), Box<dyn std::error::Error>> {
        // See if we can verify a slice from a local file.

        // Read the file in as input
        let mut f = File::open("tests/files/ethereum.pdf")?;
        let mut whole_input = Vec::new();
        f.read_to_end(&mut whole_input)?;

        let obao_data = ObaoData::new(&whole_input)?;

        // Extract our Obao Data
        let obao = obao_data.obao;
        let hash = obao_data.hash;
        let file_size = obao_data.file_size;

        // Generate a random chunk index.
        let chunk_index = generate_random_chunk_index(file_size);
        let chunk = &whole_input[chunk_index..chunk_index + BAO_CHUNK_SIZE];

        // Create a new ObaoSlice from the chunk.
        let obao_slice = ObaoSlice::new(obao, chunk, chunk_index)?;

        // Verify the ObaoSlice against the file chunk. This should return true.
        assert_eq!(obao_slice.verify(&hash)?, true);
        // Decode the ObaoSlice. This should return our original chunk.
        assert_eq!(obao_slice.decode(&hash)?, chunk);
        Ok(())
    }
}
